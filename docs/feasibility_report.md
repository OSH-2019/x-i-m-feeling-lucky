# 可行性报告

[TOC]

## 项目名称

<big>**Implementing an OS on a Raspberry Pi 3 with Rust**</big>

## 项目简介

（based on Research.md)

## 理论依据 (YL)

### Why Rust is safe?

(Rust 语言特性 ownership、option<>、)

###



## 技术依据 (LWS WRC)

### How Rust make OS safe? 

(OS里面如何用rust内禀的一些特性)

#### Samples

##### Postive

###### Redox

###### bkernel

##### Negative

###### Linux

###### Windows



### Rust is feasible (Samples) 

##### Redox

##### bkernel

##### CS140e



## 3 设计方案 (LYF)

本项目的目的是针对树莓派3B+嵌入式设备，采用Rust语言(结合一定量的ARM汇编语言)开发一个可运行的，基本功能齐全的定制OS。

我们在实现过程中会参考Stanford CS140e课程及其他操作系统开发资料，并在其上做出一定程度的调整和优化工作。

以下给出初步的设计方案，最终的实现方案可能会在开发过程中略有改变，将在以后的报告中进行说明。

### 3.0 总体架构图

![1554296083334](feasibility_report.assets/architecture_v2.0.png)

#### 3.1 从硬件到软件

树莓派上电以后会经历数阶段的boot过程，最终跳转到kernel开头的映像文件进行执行。我们首先需要使用ARM汇编语言实现一些标准的树莓派硬件驱动(GPIO、UART等)以方便更高层次上的使用，如控制LED闪烁、串口数据收发、显示屏交互等基本操作。

#### 3.2 基本数据结构

虽然Rust中定义了不少实用的数据类型，如```Vector```、```String```等结构，但是许多这样的结构都需要依赖操作系统提供的```malloc()```系统调用实现。考虑到现在的程序需要直接在 Raspberry Pi 裸机上运行，无法使用这些结构，我们必须直接基于硬件的空间来实现一些基本的数据结构以便在更高层次上实现内核所需的数据结构。以下介绍首要的两种结构。

##### 3.2.1 栈(Stack)

栈在计算机科学中可以说是最重要的数据结构之一，在最基本的层面就有栈的存在，故把栈的实现放在此处。

栈支持的最主要操作是入栈```push```、出栈```pop```和查看栈顶元素```top```。

##### 3.2.2 Volatile

在 Rust 中有类似C语言中volatile关键字的用法，使编译器不对内存读写进行优化，直接在指定的内存地址读取或写入数据。

对于内存映射寄存器、内存映射 I/O 等，不仅用户编写的程序需要对其进行读写，硬件状态等各种外部因素，也会影响其中的值。所以需要保证每次读取的数据都为最新值，每次写入都能正确、及时进行。在这种情况下，使用 volatile 就比较有意义了。

在我们的实现中，将针对一些基本数据类型进行Volatile改进。

#### 3.3 内核数据结构

在内核中应当实现一些标准内建的通用数据结构、这会为后续的内核开发带来极大的方便。在上学期的课程中我们已经初步掌握了数据结构的原理、实现与使用，而内核开发中最常用的有以下几种。

##### 3.3.1 链表(Link List)

最简单、最普通的数据结构，但相当有用。它是一种存放和操作可变数量元素(结点)的数据结构，其所包含的元素都是动态创建并插入的。由于链表中各个元素的创建时间一般各不相同，所以它们在内存中无需占用连续的内存区，也就是说，通过指针操作即可简单地实现链表。

除了创建```init```、清空```clear```、销毁```destroy```等基本操作，链表的特征操作有插入元素```insert```、删除元素```delete```、查找元素```search```、遍历```traverse```等。而随着用途的不同，它也会要求实现一些其它的操作，如移动```move```或合并```merge```结点。

在操作系统内核的开发中，链表可以用于一系列动态数据的管理。比如存储管理中可分配存储的链表、进程管理中用于表示进程状态的PCB连接的链表等。

##### 3.3.2 队列(Queue)

对任何操作系统内核来说，生产者和消费者的编程模型是必不可少的。在该模式中，生产者创造数据(错误信息、数据包)而消费者读取这些信息和数据并以某种方式来消费这些数据，一般来说消费者获取数据的顺序和加入队列的顺序是一致的，也就是遵守FIFO规则。队列是实现这种FIFO模型的最简单的方式。其可以简单地基于数组或链表来实现。

队列至少需要支持入队```enqueue```、出队```dequeue```的基本特殊操作。

在操作系统内核的开发中，队列适合一切基于FIFO规则的模型。比如进程管理中的多级队列调度算法中的任务队列、进程通信中的消息队列等。

##### 3.3.3 映射(Map)

映射，又名关联数组，是由唯一键组成的集合，维护一组键值对(Key-value pair)。使用散列表(Hash table)可以实现之，我们的实现中主要利用它。

映射至少要支持添加键值对```add```、删除键值对```remove```和根据键查找对应值```value```的操作。

在操作系统内核的开发中，映射通常用于实现映射关系。比如文件系统中的Hash文件、内存分配的Hash算法等。

##### 3.3.4 二叉树(Binary Tree)

按照所需的用途更具体地说应该是二叉平衡搜索树(Balanced BST)或者是其中的一种实现——红黑树，我们需要这样一种数据结构来对需要迅速检索的大量数据来进行维护。其实现相比上述三种来说要复杂，此处不予赘述。

红黑树需要支持的操作同链表与映射类似，不过其性能优于链表，能够保证搜索的时间复杂度为对数关系，按序遍历为线性关系。

在操作系统内核的开发中，树常用于大量数据的管理或树形结构的表示。比如文件系统中的目录树等。



#### 3.4 文件系统

文件系统提供了在线存储和访问计算机操作系统和所有用户的程序与数据的机制。其由两个不同的部分组成：一组文件(用于存储相关数据)和目录结构(用于组织系统内的文件并提供有关文件的信息)。而对于我们的实现方案来说，需要考虑以下一些问题。

##### 3.4.1 类型选择

处于兼容性与简单的考虑，我们决定重新实现一个FAT32文件系统。开发过程中必须严格按照其标准来实现。

##### 3.4.2 实现相关

本项目中使用的SD卡存储设备采用MBR(Master Boot Record)分区表，故我们可以基于它来获取分区信息并实现文件系统。

MBR 位于磁盘的前 512 个字节，能够保存四条分区记录，对应四个分区。每条分区记录中，保存有分区的类型(0xb 或 0xc 代表 FAT32)，以及起始位置和大小。MBR 的最后两个字节为 0x55, 0xaa，用于检查磁盘是否使用了 MBR。而EBPB (Extended Bios Parameter Block) 位于每个分区起始位置，包含关于磁盘和分区的重要信息。读取方式与 MBR 基本相同。

在实际实现的代码中，需要读取 MBR 后，填充到结构体，并检查其中内容无误。



#### 3.5 内存管理

我们的项目将运行在树莓派裸金属上，不需要考虑虚拟地址空间的设计。

在ARM CPU 中，有部分内存地址区域中，保存有关于该 CPU 的一些信息，例如内存大小等。这些信息以类似TLV的形式进行保存，可通过程序进行遍历，获取必要的信息。

而为了让我们的OS可以合理地管理内存，就需要实现存储控制方面的函数，比如可以通过读取 ATAGS，获取内存的大小和起始位置，并返回可用内存地址范围。

我们实现的操作系统会将可用内存范围组织成链表，基于此来进行内存分配、释放和碎片整理等操作。

##### 3.5.1 内存分配算法

##### 3.5.2 内存释放

##### 3.5.3 碎片整理 



#### 3.6 进程管理

进程管理是操作系统中一个非常重要的概念。在这一部分中，我们将考虑进程的资源分配、信息维护以及调度方案。

##### 3.6.1 进程信息维护

在进程的控制中，必须维护一些关于进程的信息，在我们的实现中，采用标准的进程控制块(PCB)链表结构。

对于内核，在PCB中需要为每个进程维护如下信息：

- 栈
- 堆
- 父进程
- 可执行代码
- 调度器状态（进程是否需要被得到调度）
- 运行状态（寄存器等信息，方便上下文切换后进行恢复）

##### 3.6.2 进程调度

事实上，线程是进程调度的最小单位。此处暂时不做区别，一概以进程相称。

常用的进程调度策略有以下一些，出于性能考虑，我们希望以抢占式算法(RR、MFQS)为主要算法，多种调度算法相结合的设计策略。

- 先到先服务策略(FCFS)：最简单的CPU调度策略，可以直接用一个队列简单实现，不过问题也层出不穷，如考虑I/O时CPU与设备利用率相对较低。
- 最短作业优先调度策略(SJF)：理论上的优秀算法，但在实际实现中，由于无法知道下一个CPU区间的长度，故不能在短期CPU调度层次上加以实现。
- 优先级调度策略(PS)：每个进程都有一个关联的优先级，高优先级优先。虽然比较灵活但仍存在饥饿的主要问题。
- 轮转法调度策略(RR)：专为分时系统设计，类似FCFS，但增加了抢占以切换进程，是公平的调度策略。
- 多级反馈队列调度策略(MFQS)：较为成熟的调度策略，可以对其中不同的队列按照情况使用不同的调度算法，并可以控制进程在队列中的进出。

我们在初步的的实现中希望采取轮转法作为主要策略，有余裕则尝试实现MFQS策略。



#### 3.7 其它部分
